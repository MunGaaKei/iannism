<html><head><meta charset="utf-8"><title>鼠标移入移出方向判断</title><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><link rel="shortcut icon" href="../ico.ico" type="image/x-icon"><link rel="stylesheet" href="http://at.alicdn.com/t/font_ad90zq63j3akmx6r.css"><link rel="stylesheet" href="../css/blog.css"><link rel="stylesheet" href="../css/prism.css">
<style>    .m-box{
      position: relative;
      overflow: hidden;
      width: 150px;
      height: 150px;
      background: #ddd;
      display: inline-block;
      margin: 10px;
    }
    .m-mask{
      position: absolute;
      left: -100%;
      top: 0;
      height: 100%;
      width: 100%;
      background: #333;
    }.m-trans{ transition: all .3s ease; }</style></head><body><div class="container"><header id="header" class="clearfix"><h2>鼠标移入移出方向判断</h2><p class="info">On 2017-2-13 by <a href="https://mungaakei.github.io/picasso">GaaKei</a><a href="#" class="fr">顶部</a><a href="https://mungaakei.github.io/picasso/#blog" class="fr">更多</a></p></header><div class="content">这是一篇关于如何使用Javascript判断鼠标移入移出方向的文章。<div><br></div><div>效果如下</div><div>&gt;&gt;</div><div><br></div><div style="text-align: center;">
  <div class="m-box">
    <div class="m-mask"></div>
  </div><div class="m-box">
    <div class="m-mask"></div>
  </div>
</div><div><br></div><h2>判断思路</h2><div><br></div><div>大概实现的思路是在鼠标移入或移出的那一刻根据鼠标指针相对于目标元素中心位置来进行判断。</div><div><br></div><div><div><img src="image/1.png"><br></div></div><div><br></div><div>假设鼠标从<b>p</b>点移入或移出目标元素，那么根据目标元素中心位置<b>o( x0, y0 )</b>和点<b>p( x, y )</b>可以得出斜率<b>k0</b>。</div><div><b>k</b>为目标元素左下角与右上角对角线斜率。</div><div><br></div><div>根据斜率比较，我们可以知道鼠标移入或移出方向的两种情况：</div><div>1)上下：k0 ∈ ( k , +∞)∪( -∞, -k )</div><div>2)左右：k0 ∈ ( -k, k )</div><div><br></div><div>然后再根据这两种情况分别进行细分：</div><div>1)上下：</div><div>　　当y&gt;y0, 即为上<br></div><div>　　当y&lt;y0, 即为下<br></div><div>2)左右：</div><div>　　当x&lt;x0, 即为左<br></div><div>　　当x&gt;x0, 即为右<br></div><div><br></div><div>关于判断的思路到此，后面是具体的示例实现方法。</div><div><br></div><div><br></div><div><br></div><h2>具体实现</h2><div><br></div><div>示例结构</div><div>&gt;&gt;</div><div><br></div><pre><code class="language-html">&lt;div class="m-box"&gt;
　　&lt;div class="m-mask"&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre><div><br></div><div><br></div><div>样式设置</div><div>&gt;&gt;</div><div><br></div><div><pre><code class="language-css">.box{
	position: relative;
	overflow: hidden;
	/* ...... */
}
.mask{
	position: absolute;
	left: -100%;
	top: 0;　　/* 隐藏起来即可 */
	/* ...... */
}
.trans{
	transition: all .3s ease;　　/* 需要用到 */
}</code></pre><br></div><div><br></div><div>那么，结构以及表现层已经准备好，下面是行为层了。</div><div><br></div><div>先假设鼠标从上方移入box，那么mask则应当在box上方就位然后移入box里。根据四个方向，我们可以先为这四种情况设置好位置：</div><div>&gt;&gt;</div><div><br></div><div><br></div><div><pre><code class="language-js">var pos = {
      left: { left: '-100%', top: '0'},
      top: { left: '0', top: '-100%'},
      right: { left: '100%', top: '0'},
      bottom: { left: '0', top: '100%'}
    },
    dir = ['left', 'top', 'right', 'bottom'],
    rect, k0, k, opt,
    x0, y0;</code></pre><br></div><div>然后再添加鼠标移入移出事件监听，文字主要写在注释上</div><div>&gt;&gt;</div><div><br></div><div><pre><code class="language-js">$('div.m-box').on('mouseenter',function(e){
  rect = this.getBoundingClientRect();　　// 获取box相对于页面的位置以及它的宽高<font color="#fd0000">*</font>

  //在页面中，坐标相当处于第四象限，所以注意横坐标符号不变，纵坐标值则取反
  x0 = rect.left + rect.width/2;
  y0 = -(rect.top + rect.height/2);

  k = (-rect.top - y0) / (rect.right - x0);　　// 即用box右上点与其中心点O求出k
  k0 = (-e.clientY - y0) / (e.clientX - x0);　　// 求出鼠标位置与中心点O的斜率k0

  // 现在我们可以开始判断进入方向了
  if (Math.abs(k0) &lt; k) {
    //左右进入 对应上面的第二种情况
    //至于左右 只要根据鼠标的横坐标值与中心点O的横坐标值相比就可以判断出来了
    opt = e.clientX &lt; x0 ? 0 : 2;　　//0表示从左边进入 2为右边
  } else {
    // 上下进入
    opt = -e.clientY &gt; y0 ? 1 : 3;　　//1表示从上边进入 3为下边
  }

  boxEnter(this, opt);　　//传入box对象与方向到效果函数

}).on('mouseleave',function(e){
  rect = this.getBoundingClientRect();　　//获取box相对于页面的位置以及它的宽高

  //在页面中，坐标相当处于第四象限，所以注意横坐标符号不变，纵坐标值则取反
  x0 = rect.left + rect.width/2;
  y0 = -(rect.top + rect.height/2);

  k = (-rect.top - y0) / (rect.right - x0);　　//即用box右上点与其中心点O求出k
  k0 = (-e.clientY - y0) / (e.clientX - x0);　　//求出鼠标位置与中心点O的斜率k0

  //现在我们可以开始判断进入方向了
  if (Math.abs(k0) &lt; k) {
    //左右进入 对应上面的第二种情况
    //至于左右 只要根据鼠标的横坐标值与中心点O的横坐标值相比就可以判断出来了
    opt = e.clientX &lt; x0 ? 0 : 2;　　//0表示从左边进入 2为右边
  } else {
    // 上下进入
    opt = -e.clientY &gt; y0 ? 1 : 3;　　//1表示从上边进入 3为下边
  }

  boxLeave(this, opt);
});

function boxEnter(element, opt){
	var mask = $(element).find('div.mask');
	mask.removeClass('trans').css(pos[dir[opt]]);　　//移除动画效果<font color="#fd0000">*</font>
	mask[0].offsetWidth;　　//回流<font color="#fd0000">*</font>
	mask.addClass('trans').css({
		left: 0, top: 0
	});
}

function boxLeave(element, opt){
	$(element).find('div.mask').css(pos[dir[opt]]);
}</code></pre><br></div><div>关于 <b>*</b>：</div><div><br></div><div>1)：<b>getBoundingClientRect()</b>可以返回目标元素数据的一个对象数组，这些数据包括该元素的宽、高以及各边相对页面边界的距离。</div><div><br></div><div>2)：移除动画效果的目的是为了让mask立即复位到指定位置而不通过transition。如果不移除，mask会出现掠过box的画面。比如上一个操作是从右移出，那么mask现在的位置处于box右边[<b>left: 100%</b>]。此时如果鼠标从左边移入，那么mask就会通过transition动画从[<b>left: 100%</b>]移动到[<b>left: -100%</b>]，显然不是我们想要的效果。而移除了transition，mask就不会出现这种问题了。</div><div><br></div><div>3)：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为<b>回流</b>。</div><div><br></div><div><br></div><div>感谢阅读</div><div><i><br></i></div><div><i><br></i></div></div></div><script>document.getElementById("nighttoggle").addEventListener("click", function(){document.querySelector("body").classList.toggle("night");});</script><script src="../js/prism.js"></script>
<script src="../js/jquery-3.1.1.min.js"></script>
<script>document.addEventListener('mousewheel', function(e){if(e.wheelDeltaY > 0){document.getElementById('header').classList.remove('hide');} else {document.getElementById('header').classList.add('hide');}});
document.addEventListener('DOMMouseScroll', function(e){if(e.detail < 0){document.getElementById('header').classList.remove('hide');} else {document.getElementById('header').classList.add('hide');}});</script>
<script>
(function() {
var pos = {
      left: { left: '-100%', top: '0'},
      top: { left: '0', top: '-100%'},
      right: { left: '100%', top: '0'},
      bottom: { left: '0', top: '100%'}
    },
    dir = ['left', 'top', 'right', 'bottom'],
    rect, k0, k, opt,
    x0, y0;

$('div.m-box').on('mouseenter',function(e){
  rect = this.getBoundingClientRect(); // 获取box相对于页面的位置以及它的宽高

  // 在页面中，坐标相当处于第四象限，所以注意横坐标符号不变，纵坐标值则取反
  x0 = rect.left + rect.width/2;
  y0 = -(rect.top + rect.height/2);

  k = (-rect.top - y0) / (rect.right - x0); // 即用box右上点与其中心点O求出k
  k0 = (-e.clientY - y0) / (e.clientX - x0); // 求出鼠标位置与中心点O的斜率k0

  // 现在我们可以开始判断进入方向了
  if (Math.abs(k0) < k) {
    // 左右进入 对应上面的第二种情况
    // 至于左右 只要根据鼠标的横坐标值与中心点O的横坐标值相比就可以判断出来了
    opt = e.clientX < x0 ? 0 : 2; // 0表示从左边进入 2为右边
  } else {
    // 上下进入
    opt = -e.clientY > y0 ? 1 : 3; // 1表示从上边进入 3为下边
  }

  boxEnter(this, opt); // 传入box对象与方向到效果函数

}).on('mouseleave',function(e){
  rect = this.getBoundingClientRect(); // 获取box相对于页面的位置以及它的宽高

  // 在页面中，坐标相当处于第四象限，所以注意横坐标符号不变，纵坐标值则取反
  x0 = rect.left + rect.width/2;
  y0 = -(rect.top + rect.height/2);

  k = (-rect.top - y0) / (rect.right - x0); // 即用box右上点与其中心点O求出k
  k0 = (-e.clientY - y0) / (e.clientX - x0); // 求出鼠标位置与中心点O的斜率k0

  // 现在我们可以开始判断进入方向了
  if (Math.abs(k0) < k) {
    // 左右进入 对应上面的第二种情况
    // 至于左右 只要根据鼠标的横坐标值与中心点O的横坐标值相比就可以判断出来了
    opt = e.clientX < x0 ? 0 : 2; // 0表示从左边进入 2为右边
  } else {
    // 上下进入
    opt = -e.clientY > y0 ? 1 : 3; // 1表示从上边进入 3为下边
  }
  boxLeave(this, opt);
});
function boxEnter(element, opt){
	var mask = $(element).find('div.m-mask');
	mask.removeClass('m-trans').css(pos[dir[opt]]);
	mask[0].offsetWidth;  // reflow回流
	mask.addClass('m-trans').css({
		left: 0, top: 0
	});
}

function boxLeave(element, opt){
	$(element).find('div.m-mask').css(pos[dir[opt]]);
}

})();
</script>
</body></html>
