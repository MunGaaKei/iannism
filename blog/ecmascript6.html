<html><head><meta charset="utf-8"><title>接触 ECMAScript6</title><meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1">
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><link rel="shortcut icon" href="../ico.ico" type="image/x-icon"><link rel="stylesheet" href="../css/blog.css"><link rel="stylesheet" href="../css/prism.css"></head>
<body>
<!-- insert .container -->
<div class="container"><header id="header" class="header clearfix"><h2>接触 ECMAScript6</h2><p><a href="https://mungaakei.github.io/picasso">满家淇</a><time>2017-5-2</time><a href="#" class="fr">顶部</a><a href="https://mungaakei.github.io/picasso/#blog" class="fr">更多</a></p></header><div class="content">这是一篇简单介绍<b>ECMAScript6</b>的文章。<div><br></div><div><br></div><div>ECMAScript6，是发布于2015年的新一代JavaScript语言标准，以下简称ES6。</div><div><br></div><div>就像CSS3以及HTML5，JavaScript也会跟着进化。虽然本人现在常用的还是ES5，但学习ES6也是非常有必要的。除了开发，对你阅读别人写的代码也会有方便之处，因为采用ES6开发的项目也会越来越多。考虑到以后会常用，所以写下此文以备自己不时之需。当有了对其更深的了解会进行补充。</div><div><br></div><div>需要注意的是ES6还未达到所有浏览器支持的程度，在项目上使用需要进行考虑。</div><div>而&nbsp;<a href="http://babeljs.cn/">Babel</a>&nbsp;可以进行ES6向ES5的转换。</div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>let</h1><div><br></div><div>在ES5中，我们使用的是 var，到了ES6，我们需要常用 let 了。ES5中的作用域分为全局和函数内部，而 let 让JavaScript新增了块级作用域。</div><div><b>let 声明的变量只在其所处的代码块内有效</b>，与 var 的区别可以参考下面代码。</div><div><br></div><div><pre><code class="language-js">var a = [],
    b = [];

for(var i= 0; i&lt; 3; i++){
  a[i] = function(){
    console.log(i);
  }
}
console.log(i);  // 3
a[1]();  // 3

for(let j= 0; j&lt; 3; j++){
  b[j] = function(){
    console.log(j);
  }
}
console.log(typeof j);  // undefined
b[1]();  // 1</code></pre><br></div><div>观察上面的代码，在 var 的例子里，本来我们希望 a[i]() 可以输出赋值时 i 的值（a[1]() =&gt; 1），但每个 a[i]() 输出的值都是3。</div><div>这是因为循环过后 i 的值已经变成 3，通常我们都会使用闭包解决这个问题。而换成使用 let 后，你会发现很好的解决了这个问题。所以在以后类似循环读取索引时，我们可以用 let 替代繁琐的闭包方法。</div><div><br></div><div>let 声明的变量只能在声明后进行使用，不存在变量提升。</div><div><br></div><div><br></div><h1>const</h1><div><br></div><div>除了 let，还有 const 也是一种声明变量方式。不同的地方是 const 声明的变量相当于是只读（read-only）的，不可重新赋值。</div><div><br></div><div>如果尝试重新赋值则会报错 &gt;&gt;</div><div><br></div><div><pre><code class="language-js">const a = 1;

a = 2;  // Uncaught TypeError: Assignment to constant variable.</code></pre><br></div><div>这在避免变量重声明方面会有所帮助。</div><div><br></div><div><br></div><div><br></div><div><br></div><h1>class</h1><div><br></div><div>如你联想到C, JAVA的话是对的。ES6更明确了类的概念，相比以前的prototype... 其结构（如下）看起来会更加易懂。</div><div><br></div><div><pre><code class="language-js">class Obj {
  constructor(type) {
    this.type = type;
  }
  say( word ){
    console.log(this.type + ' says ' + word);
  }
}

let animal = new Obj('Animal');
animal.say('hi');  // Animal says meow

class Cat extends Obj {
  constructor() {
    super();
    this.type = 'cat';
  }
}

let cat = new Cat();
cat.say('meow');  // Cat says meow</code></pre>在这里首先创建了父类 Obj。在 constructor 里定义的属性和方法是仅属于该实例，而在 constructor 外定义的属性和方法则所有实例可以共享。<b>在这里 this 指向该实例对象。</b></div><div><br></div><div>关于 super() ，子类是没有自己的 this 对象的，调用该方法才能使子类获取 this 对象。如果子类没有调用 super() 则会报错，子类中的 this 为 undefined。</div><div><br></div><div>## ES6中，类不同于函数，是需要先声明才能使用的。</div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>arrow function</h1><div><br></div><div>在ES6中，函数的写法会更加简洁。</div><div><br></div><div><pre><code class="language-js">() =&gt; { return 3; } // ① 无参数时括号不可以省略
x =&gt; { return x * x; } // ② 单参数时括号可以省略
(x, y) =&gt; { return x + y; } // ③ 多参数时括号不可以省略</code></pre></div><div><br></div><div>其中大括号 {} 会被解析成代码块，默认执行完是不返回值的。</div><div>而如果这样写： (x, y) =&gt; x + y; 的效果是和第③条例子一样的，均返回 x + y 的值。</div><div>如果需要返回一个对象类型，则需要在大括号 {} 外加上小括号 () 比如：</div><div><br></div><div><pre><code class="language-js">() =&gt; ({ type:  "json" })</code></pre></div><div><br></div><div>箭头函数里的 this 指向的是定义时所处的对象，而不是使用时所处的对象，如下。</div><div><br></div><div><pre><code class="language-js">let a = {
  x: "x x",
  y: function(){
    console.log(this.x);
  }
}
a.y();  // x x

let b = {
  x: "o o",
  y: () =&gt; {
    console.log(this.x);
  }
}
b.y();  // undefined</code></pre><div><br></div>根据上面的特性，我们可以用来解决类似&nbsp;setTimeout 的问题，参考如下。</div><div><br></div><div><pre><code class="language-js">let c = {
  x: '= =',
  y: function(){
    setTimeout(function(){
      console.log(this.x);
    }, 1000);
  }
}
c.y();  // undefined

let d = {
  x: '-0-',
  y: function(){
    setTimeout(() =&gt; {
      console.log(this.x);
    }, 1000);
  }
}
d.y();  // -0-</code></pre><br></div><div><br></div><div>箭头函数参数方面，我们可以使用得更加灵活。在函数内部如果需要使用默认值，在ES5的时候，我们通常会这么做：</div><div><br></div><div><pre><code class="language-js">function hi( x ){
  console.log(x || 'hello');
}
hi();  // hello
hi('hi');  // hi</code></pre><div><br></div>而在ES6，我们可以这么写得到相同的结果：</div><div><br></div><div><pre><code class="language-js">let hi = (x = 'hello') =&gt; {
  console.log(x);
}
hi(); // hello
hi('hi');  // hi</code></pre><br></div><div><br></div><div>ES6中使用 Rest参数 来处理可变参数。</div><div><br></div><div><pre><code class="language-js">let log = (x, y, ...rest) =&gt; {
  console.log(rest);
}
log(1,2,3,4);  // [3, 4]</code></pre>与ES5中的 arguments 不同，ES6也不支持 arguments。其中Rest参数获得的是一个真正的Array实例，也就是说它可以直接使用在 sort() \ reverse() 等函数，而 arguments 则还涵盖了一些功能。<br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>&nbsp;template string</h1><div><br></div><div>这个会用在连接字符串的时候，比如：</div><div><br></div><div><pre><code class="language-js">let o = {
  x: 'he',
  y: 'ld'
}

document.getElementById('p').innerHTML = `&lt;b&gt;${o.x}llo&lt;/b&gt; w
or${o.y}!`;<br></code></pre>直接用 ${} 来引用变量，但是要注意的是整个字符串要用<b>反引号</b> ` 来标识起始，多行字符串也无需用+来连接。</div><div><br></div><div><br></div><div><br></div><div><br></div><h1>Destructuring Assignment</h1><div><br></div><div>解构赋值允许你使用类似数组或对象字面量的语法将<b>数组</b>和<b>对象</b>的属性赋给各种变量。</div><div><br></div><div>ES5时，当我们遇到下面的情况一般会分别进行赋值。</div><div><br></div><div><pre><code class="language-js">var a = array[0],
    b = array[1],
    c = array[2];</code></pre><div><br></div>而在ES6，我们可以简单的实现获取array数组的前三个值。</div><div><br></div><div><pre><code class="language-js">let [a, b, c] = array;</code></pre><br></div><div>如果你想跳过前两个值也可以这样。</div><div><br></div><div><pre><code class="language-js">let [ , , c] = array;</code></pre><div><br></div>这种方法也可以配合上面所说的Rest参数，c此时则为含第三项之后的数组。</div><div><br></div><div><pre><code class="language-js">let [a, b, ...c] = array;</code></pre><br></div><div><br></div><div><br></div><div><br></div><h1>Promise</h1><div><br></div><div>Promise对象可以理解为一次执行的<b>异步</b>操作，使用promise对象之后可以使用一种链式调用的方式来组织代码。<br></div><div>这是一个简单的promise例子。</div><div><br></div><div><pre><code class="language-js">let p = ( flag ) =&gt; {
  return new Promise(function(resolve, reject) {
    console.log(1);
    flag? resolve(2): reject(3);
  });
}

p(true).then((data) =&gt; {
  console.log(data);
  return ++data;
}).then((data) =&gt; {
  console.log(data);
  return ++data;
});

console.log(99);</code></pre>以上代码会输出：1, 99, 2, 3</div><div><br></div><div>每次调用then()都会返回一个promise对象，大概类似于jQuery对象调用方法。</div><div><br></div><div>由于本人目前也不是很了解，以后再进行更详尽的补充，所以更详细的介绍可以参考下面两篇文章：</div><div><a href="http://www.cnblogs.com/tugenhua0707/p/4771528.html">http://www.cnblogs.com/tugenhua0707/p/4771528.html</a></div><div><a href="https://segmentfault.com/a/1190000006708151">https://segmentfault.com/a/1190000006708151</a><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>Module</h1><div><br></div><div>即一个 .js 文件可以作为一个模块被其它 .js 文件引用，有两个主要命令：<b>export</b> 和 <b>import</b> 分别用于<b>导出</b>该模块接口和<b>引入</b>其它模块的接口。</div><div><br></div><div>a.js 导出：</div><div><br></div><div><pre><code class="language-js">var bear = 'Kuma',
    cat = 'Kitty',
    dog = 'Kisho';

export {
  bear,
  cat,
  dog as woof
};</code></pre><br></div><div>其中 dog as woof 是让导出变量名重命名，b.js 就可以如下导入：</div><div><br></div><div><pre><code class="language-js">import { bear as ebra, cat, woof } from "a.js";
import { bear as abre } from "c.js";

console.log( cat );</code></pre><br>当在导入变量名冲突时，也可以进行重命名。</div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>for - of</h1><div><br></div><div>for-of 不仅可以遍历数组，甚至字符串。</div><div><br></div><div><pre><code class="language-js">let a = [1, 2, 3],
    b = "cat";
for( x of a ){ console.log(x); }  // 1, 2, 3
for( y of b ){ console.log(y); }  // c, a, t</code></pre><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>Set, Map, WeakMap</h1><div><br></div><div>Set 是 ES6 新增的有序列表集合，它不会包含重复项，但不会对键作类型转换，而且只能用 <b>for-of</b> 来进行遍历。<br></div><div><br></div><div><pre><code class="language-js">let s = new Set();

s.add(1).add(2).add(2).add(3);
s.has(3);  // true
s.size;  // 3
s.delete(3);
s.has(3);  // false
s.clear();
s.size;  // 0</code></pre><div><br></div>Map 是 ES6 新增的有序键值对集合。键值对的 key 和 value 都可以是任何类型的元素。<br></div><div><br></div><div><pre><code class="language-js">let m = new Map(),
    k1 = 1,
    k2 = 2;

m.set(k1, 3);
m.set(k2, 2);
m.has(k2);  // true
m.get(k1);  // 3 (覆盖旧值)
m.delete(k2);
m.size;  // 1
m.clear();</code></pre><br></div><div>WeakMap 相对于 Map，它要求键不能是空对象。而且如果没有别的变量或函数引用到它们（WeakMap里存的键值），那么它们就会被回收释放掉。</div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>Proxy</h1><div><br></div><div>Proxy拥有监听目标使用（读写）的能力，并可以为发生这些行为时做出相应的操作。当你想要实现数据绑定之类的功能时，使用Proxy不失为一个良好的方法。<br></div><div><br></div><div><pre><code class="language-js">let o = { a: 1 },
    handle = {
      set: (target, key, value) =&gt; {
        console.log(key, 'now is', value);
      },
      get: (target, key) =&gt; {
        console.log(target[key]);
      }
    };

let p = new Proxy(o, handle);  // 创建代理进行监听
p.a = 2;  // 触发代理 执行set，控制台输出：a now is 2
p.a;  // 触发代理 执行get，控制台输出 1</code></pre><br></div><div><br></div><div>参考资料：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>数据 API</h1><div><br></div><div><br></div><div>ES6对Object、Array、String等类型的API做出了更新。</div><div>参考文章：<a href="http://www.jianshu.com/p/e19a4764e9dd?nomobile=yes">http://www.jianshu.com/p/e19a4764e9dd?nomobile=yes</a></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><b>谢谢阅读</b></div><div><br></div></div></div>

<script src="../js/prism.js"></script>
<script>
(function(){var y = 0, dy = 0, d = document;
  d.addEventListener('touchstart', function(e){y = e.touches[0].pageY;});
  d.addEventListener('touchmove', function(e){
    dy = e.touches[0].pageY - y;
    if(dy > 0){d.getElementById('header').classList.remove('hide');}else{d.getElementById('header').classList.add('hide');}});
  d.addEventListener('mousewheel', function(e){if(e.wheelDeltaY > 0){d.getElementById('header').classList.remove('hide');} else {d.getElementById('header').classList.add('hide');}});
d.addEventListener('DOMMouseScroll', function(e){if(e.detail < 0){d.getElementById('header').classList.remove('hide');} else {d.getElementById('header').classList.add('hide');}});
})();</script>
</body>
