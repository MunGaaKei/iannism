<html><head><meta charset="utf-8"><title>接触ECMAScript6</title>
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><link rel="shortcut icon" href="../ico.ico" type="image/x-icon"><link rel="stylesheet" href="http://at.alicdn.com/t/font_ad90zq63j3akmx6r.css"><link rel="stylesheet" href="../css/blog.css"><link rel="stylesheet" href="../css/prism.css"></head>
<body>
<!-- insert .container -->
<div class="container"><header class="clearfix"><h2>接触 ECMAScript6</h2><p class="info">On 2017-5-23 by <a href="https://mungaakei.github.io/picasso">GaaKei</a></p></header><div class="content">这是一篇简单介绍<b>ECMAScript6</b>的文章。<div><br></div><div><br></div><div>ECMAScript6，是发布于2015年的新一代JavaScript语言标准，以下简称ES6。</div><div><br></div><div>就像CSS3以及HTML5，JavaScript也会跟着进化。虽然本人现在常用的还是ES5，但学习ES6也是非常有必要的。除了开发，对你阅读别人写的代码也会有方便之处，因为采用ES6开发的项目也会越来越多。考虑到以后会常用，所以写下此文以备自己不时之需。当有了对其更深的了解会进行补充。</div><div><br></div><div>需要注意的是ES6还未达到所有浏览器支持的程度，在项目上使用需要进行考虑。</div><div>而&nbsp;<a href="http://babeljs.cn/">Babel</a>&nbsp;可以进行ES6向ES5的转换。</div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>let</h1><div><br></div><div>在ES5中，我们使用的是 var，到了ES6，我们需要常用 let 了。ES5中的作用域分为全局和函数内部，而 let 让JavaScript新增了块级作用域。</div><div><b>let 声明的变量只在其所处的代码块内有效</b>，与 var 的区别可以参考下面代码。</div><div><br></div><div><pre><code class="language-js">var a = [],
    b = [];

for(var i= 0; i&lt; 3; i++){
  a[i] = function(){
    console.log(i);
  }
}
console.log(i);  // 3
a[1]();  // 3

for(let j= 0; j&lt; 3; j++){
  b[j] = function(){
    console.log(j);
  }
}
console.log(typeof j);  // undefined
b[1]();  // 1</code></pre><br></div><div>观察上面的代码，在 var 的例子里，本来我们希望 a[i]() 可以输出赋值时 i 的值（a[1]() =&gt; 1），但每个 a[i]() 输出的值都是3。</div><div>这是因为循环过后 i 的值已经变成 3，通常我们都会使用闭包解决这个问题。而换成使用 let 后，你会发现很好的解决了这个问题。所以在以后类似循环读取索引时，我们可以用 let 替代繁琐的闭包方法。</div><div><br></div><div><br></div><h1>const</h1><div><br></div><div>除了 let，还有 const 也是一种声明变量方式。不同的地方是 const 声明的变量相当于是只读（read-only）的，不可重新赋值。</div><div><br></div><div>如果尝试重新赋值则会报错 &gt;&gt;</div><div><br></div><div><pre><code class="language-js">const a = 1;

a = 2;  // Uncaught TypeError: Assignment to constant variable.</code></pre><br></div><div>这在避免变量重声明方面会有所帮助。</div><div><br></div><div><br></div><div><br></div><div><br></div><h1>class</h1><div><br></div><div>如你联想到C, JAVA的话是对的。ES6更明确了类的概念，相比以前的prototype... 其结构（如下）看起来会更加易懂。</div><div><br></div><div><pre><code class="language-js">class Obj {
  constructor(type) {
    this.type = type;
  }
  say( word ){
    console.log(this.type + ' says ' + word);
  }
}

let animal = new Obj('Animal');
animal.say('hi');  // Animal says meow

class Cat extends Obj {
  constructor() {
    super();
    this.type = 'cat';
  }
}

let cat = new Cat();
cat.say('meow');  // Cat says meow</code></pre>在这里首先创建了父类 Obj。在 constructor 里定义的属性和方法是仅属于该实例，而在 constructor 外定义的属性和方法则所有实例可以共享。<b>在这里 this 指向该实例对象。</b></div><div><br></div><div>关于 super() ，子类是没有自己的 this 对象的，调用该方法才能使子类获取 this 对象。如果子类没有调用 super() 则会报错，子类中的 this 为 undefined。</div><div><br></div><div>## ES6中，类不同于函数，是需要先声明才能使用的。</div><div><br></div><div><br></div><div><br></div><div><br></div><h1>arrow function</h1><div><br></div><div>在ES6中，函数的写法会更加简洁。</div><div><br></div><div><pre><code class="language-js">() =&gt; { return 3; } // ① 无参数时括号不可以省略
x =&gt; { return x * x; } // ② 单参数时括号可以省略
(x, y) =&gt; { return x + y; } // ③ 多参数时括号不可以省略</code></pre></div><div><br></div><div>其中大括号 {} 会被解析成代码块，默认执行完是不返回值的。</div><div>而如果这样写： (x, y) =&gt; x + y; 的效果是和第③条例子一样的，均返回 x + y 的值。</div><div>如果需要返回一个对象类型，则需要在大括号 {} 外加上小括号 () 比如：</div><div><br></div><div><pre><code class="language-js">() =&gt; ({ type:  "json" })</code></pre></div><div><br></div><div>箭头函数里的 this 指向的是定义时所处的对象，而不是使用时所处的对象，如下。</div><div><br></div><div><pre><code class="language-js">let a = {
  x: "x x",
  y: function(){
    console.log(this.x);
  }
}
a.y();  // x x

let b = {
  x: "o o",
  y: () =&gt; {
    console.log(this.x);
  }
}
b.y();  // undefined</code></pre><div><br></div>根据上面的特性，我们可以用来解决类似&nbsp;setTimeout 的问题，参考如下。</div><div><br></div><div><pre><code class="language-js">let c = {
  x: '= =',
  y: function(){
    setTimeout(function(){
      console.log(this.x);
    }, 1000);
  }
}
c.y();  // undefined

let d = {
  x: '-0-',
  y: function(){
    setTimeout(() =&gt; {
      console.log(this.x);
    }, 1000);
  }
}
d.y();  // -0-</code></pre><br></div><div><br></div><div>箭头函数参数方面，我们可以使用得更加灵活。在函数内部如果需要使用默认值，在ES5的时候，我们通常会这么做：</div><div><br></div><div><pre><code class="language-js">function hi( x ){
  console.log(x || 'hello');
}
hi();  // hello
hi('hi');  // hi</code></pre><div><br></div>而在ES6，我们可以这么写得到相同的结果：</div><div><br></div><div><pre><code class="language-js">let hi = (x = 'hello') =&gt; {
  console.log(x);
}
hi(); // hello
hi('hi');  // hi</code></pre><br></div><div><br></div><div>ES6中使用 Rest参数 来处理可变参数。</div><div><br></div><div><pre><code class="language-js">let log = (x, y, ...rest) =&gt; {
  console.log(rest);
}
log(1,2,3,4);  // [3, 4]</code></pre>与ES5中的 arguments 不同，ES6也不支持 arguments。其中Rest参数获得的是一个真正的Array实例，也就是说它可以直接使用在 sort() \ reverse() 等函数，而 arguments 则还涵盖了一些功能。<br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>template string</h1><div><br></div><div>这个会用在连接字符串的时候，比如：</div><div><br></div><div><pre><code class="language-js">let o = {
  x: 'he',
  y: 'ld'
}

document.getElementById('p').innerHTML = `&lt;b&gt;${o.x}llo&lt;/b&gt; wor${o.y}!`;</code></pre>直接用 ${} 来引用变量，但是要注意的是整个字符串要用<b>反引号</b> ` 来标识起始。</div><div><br></div><div><br></div><div><br></div><div><br></div><div><b>谢谢阅读</b></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div></div><aside class="aside"><ul><li><a href="https://mungaakei.github.io/picasso/#blog" title="返回目录"><i class="iconfont icon-newlisticon06"></i></a></li><li><a href="#" title="返回顶部"><i class="iconfont icon-rocket"></i></a></li></ul></aside></div>
<script src="../js/prism.js"></script>
</body>
