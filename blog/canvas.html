<html><head><meta charset="utf-8"><title>CANVAS下的星空</title><meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><link rel="shortcut icon" href="../ico.ico" type="image/x-icon"><link rel="stylesheet" href="../css/blog.css"><link rel="stylesheet" href="../css/prism.css"></head><body><div class="container"><header id="header" class="header clearfix"><h2>CANVAS下的星空</h2><p><a href="https://mungaakei.github.io/picasso">满家淇</a><time>2017-1-14</time><a href="#" class="fr">顶部</a><a href="https://mungaakei.github.io/picasso/#blog" class="fr">更多</a></p></header><div class="content">　　这是一篇简单介绍&lt;canvas&gt;使用的文章。<div><br></div><div>　　<a href="https://mungaakei.github.io/xamples/cvs-starry.html">演示效果&gt;&gt;</a><br></div><div><br></div><div>　　首先先铺好画布</div><div>　　&gt;&gt;</div><div><br></div><pre><code class="language-html">&lt;canvas id="canvas"&gt; 浏览器不支持canvas时出现的文字 &lt;/canvas&gt;</code></pre><div><br></div><div>　　在设置画布大小的时候可以我们可以直接在标签里设置，也可以使用JavaScript设置。而使用CSS设置时需要注意，这可能会引起画布拉伸从而导致得不到你想要的效果。</div><div><br></div><div>　　事实上，<b>JavaScript</b>就是接下来将要使用的画笔。<br></div><div>　　我们所要画的是星星从屏幕中心缓缓向四周扩散的效果，有一点穿梭在宇宙中的感觉。<br></div><div><br></div><div>　　那么先做好一些准备工作<br></div><div>　　&gt;&gt;</div><div><br></div><div><pre><code class="language-js">(function(){
  var cvs = document.getElementById('canvas'),
      ctx = cvs.getContext('2d'), 　　//<i>封装绘图功能的对象</i>
      w = cvs.width = window.innerWidth,　　//设置画布大小与屏幕大小一致
      h = cvs.height = window.innerHeight,
      o = [w/2, h/2],　　//保存屏幕中心点坐标
      stars = [],　　//存储星星的数组
      maxStars = 119;　　//星星数量上限

　　  ......
)();</code></pre></div><div><br></div><div><br></div><h2>星星初始化</h2><div><br></div><div><br></div><div>　　在穿梭开始的时候，星星应该散落在画布上的随机任何位置。这需要对每颗星星进行初始化，包括坐标位置，大小，飞行速度，飞行时间等等。这些都是可以根据个人想要的效果来进行调制的。<br></div><div>　　&gt;&gt;<br></div><div><br></div><div><pre><code class="language-js">  function initOneStar(){
    var posX = rand(0, w),　　//rand()函数返回第一个参数到第二个参数之间的随机整数值
        posY = rand(0, h),　　//星星的坐标值

        dx = posX - o[0],
        dy = posY - o[1],
　　    // 星星相对画布中心点的距离

        star = {
          x: posX,
          y: posY,
          r: .6,　　//初始半径
          alpha: Math.random(),　　//星星透明度
          vx: dx * .0004,　　//相对x轴飞行速度
          vy: dy * .0004,　　//相对y轴飞行速度
          vr: Math.random()/3,　　//半径增长速度
          time: rand(120, 360) 　　//飞行时间
　　　 ......　　//其它可添加的选项如星星颜色或者飞行加速度
        };

    return star;
  }

  //然后循环放入我们的数组stars[]里
  function initStars() {
    var l = maxStars;
    while(l--){ stars[l] = initOneStar();
  }</code></pre><br></div><div>　　这样stars[]已经存有了我们需要的maxStars个星星，它们各自拥有不同的坐标，飞行速度...</div><div><br></div><div><br></div><h2>绘制星星</h2><div><br></div><div><br></div><div>　　接下来需要把上面已经初始化好的星星stars[]"画"到画布上。<br></div><div>　　&gt;&gt;<br></div><div><br></div><div><pre><code class="language-js">  function draw(star) {
    ctx.beginPath();　　//开始绘制路径
    ctx.arc(star.x, star.y, star.r, 0, 360);
    //绘制圆形
　  //前两个参数为圆心坐标, 第三个参数为半径, 最后两个参数分别是起始角度与结束角度

    ctx.fillStyle = '#fff';　　//填充颜色
    ctx.globalAlpha = star.alpha;　　//透明度
    ctx.fill();　　//填充
  }

  //调用render()绘制函数就会将stars[]里的星星一颗一颗的绘制到画布上
  function render() {
    var l = maxStars;
    while(l--){ draw(stars[l]); }　　//循环画出每颗星星
  }
</code></pre><br></div><div>　　到了这里只要调用下面两个函数，一副星空图便出现在了你的屏幕上。<br></div><div><br></div><div><pre><code class="language-js">  initStars();
  render();</code></pre><br></div><div><br></div><h2>星星的飞行</h2><div><br></div><div><br></div><div>　　静止的星空似乎有点单调，试着换一种感觉。<br></div><div><br></div><div>　　让每颗星星动起来的原理很简单：<br></div><div>　　1) 擦拭掉每颗星星<br></div><div>　　2) 计算每颗星星下一次出现的位置<br></div><div>　　3) 根据重新计算好的位置再把每颗星星画上去</div><div><br></div><div><pre><code class="language-js">  function run() {
    var l = maxStars;

　  // 1) 擦拭
    // ctx.clearRect(0, 0, w, h);　　//常规清除画布内容
    cvs.width = w; 　　// 也是一种擦拭方法，但部分浏览器不支持

    // 2) 计算新位置
    while(l--){
      if(stars[l].time === 0){
        stars[l] = initOneStar();　　//飞行时间结束消亡的星星需要重新定义生成
      } else {
        var star = stars[l];
        stars[l].time--;　　//飞行了一"秒"(次)
        stars[l].x = (star.x + star.vx);　　//相对x轴速度
        stars[l].y = (star.y + star.vy);　　//相对y轴速度
        stars[l].r = star.r + star.vr * .01;　　//越飞越近故而半径增大
      }
    }

    render();　　// 3) 重绘
  }

  //最后我们只需要循环让它run()起来就好了。
  setInterval(run, 50);
</code></pre><br></div><div>感谢阅读<br></div></div></div><script>document.getElementById("nighttoggle").addEventListener("click", function(){document.querySelector("body").classList.toggle("night");});</script><script src="../js/prism.js"></script>
<script src="../js/jquery-3.1.1.min.js"></script><script>(function(){var y = 0, dy = 0, d = document;
  d.addEventListener('touchstart', function(e){y = e.touches[0].pageY;});
  d.addEventListener('touchmove', function(e){
    dy = e.touches[0].pageY - y;
    if(dy > 0){d.getElementById('header').classList.remove('hide');}else{d.getElementById('header').classList.add('hide');}});
  d.addEventListener('mousewheel', function(e){if(e.wheelDeltaY > 0){d.getElementById('header').classList.remove('hide');} else {d.getElementById('header').classList.add('hide');}});
d.addEventListener('DOMMouseScroll', function(e){if(e.detail < 0){d.getElementById('header').classList.remove('hide');} else {d.getElementById('header').classList.add('hide');}});
})();</script>
</body></html>
